# -*- coding: utf-8 -*-

from flask import Flask, request, jsonify
import hashlib
import hmac
import base64
import json
import os
from datetime import datetime

app = Flask(__name__)

# Configuraci√≥n
SECRET_KEY = os.getenv('GOOGLE_WEBHOOK_SECRET', '')  # Vac√≠o inicialmente
PORT = int(os.getenv('PORT', 5000))

# Logging
import logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def verify_signature(request_data, signature_header):
    """
    Verifica la firma de la solicitud de Google
    Solo se ejecuta si SECRET_KEY est√° configurado
    """
    # Si no hay secret configurado, permitir la solicitud (fase de validaci√≥n)
    if not SECRET_KEY:
        logger.info("‚ö†Ô∏è SECRET_KEY no configurado - Modo validaci√≥n")
        return True
    
    if not signature_header:
        logger.warning("‚ùå No se recibi√≥ header X-Goog-Signature")
        return False
    
    try:
        # Crear el hash HMAC
        expected_signature = hmac.new(
            SECRET_KEY.encode('utf-8'),
            request_data,
            hashlib.sha512
        ).digest()
        
        # Codificar en base64
        expected_signature_b64 = base64.b64encode(expected_signature).decode('utf-8')
        
        # Comparar de forma segura
        is_valid = hmac.compare_digest(expected_signature_b64, signature_header)
        
        if is_valid:
            logger.info("‚úÖ Firma verificada correctamente")
        else:
            logger.warning("‚ùå Firma inv√°lida")
        
        return is_valid
    
    except Exception as e:
        logger.error(f"‚ùå Error verificando firma: {e}")
        return False


@app.route('/', methods=['GET'])
def home():
    """
    Endpoint de informaci√≥n
    """
    return jsonify({
        'status': 'online',
        'service': 'Google RCS Business Messaging Webhook',
        'timestamp': datetime.utcnow().isoformat(),
        'validation_mode': not bool(SECRET_KEY),
        'endpoints': {
            'webhook': '/webhook',
            'health': '/health'
        }
    }), 200


@app.route('/webhook', methods=['POST'])
def webhook():
    """
    Endpoint principal para recibir mensajes de Google RCS
    """
    try:
        # Log de headers para debugging
        logger.info("=" * 50)
        logger.info("üì® Nueva solicitud recibida")
        logger.info(f"Headers: {dict(request.headers)}")
        
        # Obtener el contenido de la solicitud
        request_data = request.get_data()
        signature = request.headers.get('X-Goog-Signature')
        
        logger.info(f"Signature recibida: {signature if signature else 'NINGUNA'}")
        logger.info(f"Tama√±o del payload: {len(request_data)} bytes")
        
        # Verificar firma (solo si SECRET_KEY est√° configurado)
        if not verify_signature(request_data, signature):
            logger.warning("‚ùå Verificaci√≥n de firma fall√≥")
            return jsonify({'error': 'Invalid signature'}), 401
        
        # Parsear JSON
        data = request.get_json()
        
        if not data:
            logger.warning("‚ùå No se recibi√≥ data JSON")
            return jsonify({'error': 'No data received'}), 400
        
        # --- ESTA L√çNEA YA IMPRIME EL JSON COMPLETO PARA DEPURACI√ìN ---
        logger.info(f"üì¶ Payload recibido:\n{json.dumps(data, indent=2)}")
        
        # Determinar el tipo de evento
        event_type = detect_event_type(data)
        logger.info(f"üìå Tipo de evento: {event_type}")
        
        # =======================================================================
        # INICIO DE LA MODIFICACI√ìN FINAL: VERIFICACI√ìN CORRECTA
        # =======================================================================
        
        # Caso especial: Verificaci√≥n inicial de Google que incluye 'clientToken' y 'secret'
        if event_type == 'unknown' and 'clientToken' in data and 'secret' in data:
            logger.info("üîë Recibida petici√≥n de verificaci√≥n especial.")
            
            verification_secret = data.get('secret')
            client_token = data.get('clientToken')
            
            logger.info(f"üîì Respondiendo 200 OK con el secreto: {verification_secret} (para clientToken: {client_token})")
            # Simplemente devolvemos el secreto como pide Google, sin comparar.
            return jsonify({'secret': verification_secret}), 200

        # =======================================================================
        # FIN DE LA MODIFICACI√ìN
        # =======================================================================
        
        if event_type == 'message':
            handle_message(data) # <-- AQU√ç LLAMAMOS A LA FUNCI√ìN MEJORADA
        elif event_type == 'userStatus':
            handle_user_status(data)
        elif event_type == 'receipt':
            handle_receipt(data)
        elif event_type == 'suggestionResponse':
            handle_suggestion_response(data)
        else:
            logger.warning(f"‚ö†Ô∏è Tipo de evento desconocido: {list(data.keys())}")
        
        # Responder con 200 OK (MUY IMPORTANTE para validaci√≥n de Google)
        logger.info("‚úÖ Respondiendo 200 OK")
        logger.info("=" * 50)
        return jsonify({'status': 'success'}), 200
    
    except json.JSONDecodeError as e:
        logger.error(f"‚ùå Error parseando JSON: {e}")
        return jsonify({'error': 'Invalid JSON'}), 400
    
    except Exception as e:
        logger.error(f"‚ùå Error procesando webhook: {e}", exc_info=True)
        return jsonify({'error': 'Internal server error'}), 500


def detect_event_type(data):
    """
    Detecta el tipo de evento recibido
    """
    if 'message' in data:
        return 'message'
    elif 'userStatus' in data:
        return 'userStatus'
    elif 'receipt' in data:
        return 'receipt'
    elif 'suggestionResponse' in data:
        return 'suggestionResponse'
    else:
        return 'unknown'


# =============================================================================
# FUNCI√ìN MEJORADA PARA MANEJAR MENSAJES
# =============================================================================
def handle_message(data):
    """
    Procesa los mensajes/eventos de usuario (una vez pasada la verificaci√≥n).
    Identifica el tipo de contenido (texto, tarjeta, etc.) y extrae los datos.
    """
    logger.info("üöÄ Iniciando procesamiento de un nuevo mensaje...")
    
    # 1. Extraer informaci√≥n del remitente
    sender_info = data.get('senderInformation', {})
    sender_phone = sender_info.get('senderPhoneNumber') or data.get('senderPhoneNumber', 'Desconocido')
    
    # 2. Extraer el contenido del mensaje
    message_content = data.get('message', {})
    message_id = message_content.get('messageId', 'ID_No_Disponible')
    timestamp = data.get('sendTime', 'Timestamp_No_Disponible')

    # 3. Imprimir cabecera del mensaje procesado
    print("\n" + "="*50)
    print(f"üí¨ NUEVO MENSAJE RECIBIDO DE: {sender_phone}")
    print("="*50)

    # 4. Manejar diferentes tipos de contenido del mensaje
    if 'textEvent' in message_content:
        # Es un mensaje de texto
        text_data = message_content.get('textEvent', {})
        text_content = text_data.get('text', 'Mensaje sin texto')
        print(f"üìù Tipo: Mensaje de Texto")
        print(f"   Contenido: '{text_content}'")

    elif 'richCardEvent' in message_content:
        # Es una tarjeta interactiva (carrusel, etc.)
        card_data = message_content.get('richCardEvent', {})
        print(f"üé® Tipo: Tarjeta Interactiva (Rich Card)")
        print(f"   Contenido de la tarjeta: {json.dumps(card_data, indent=4)}")

    elif 'standaloneCardEvent' in message_content:
        # Es una tarjeta individual
        card_data = message_content.get('standaloneCardEvent', {})
        print(f"üÉè Tipo: Tarjeta Individual (Standalone Card)")
        print(f"   Contenido de la tarjeta: {json.dumps(card_data, indent=4)}")
    
    else:
        # Es un mensaje vac√≠o o de un tipo no reconocido
        print(f"‚ùì Tipo: Mensaje vac√≠o o no reconocido")

    print(f"üÜî ID del Mensaje: {message_id}")
    print(f"‚è∞ Enviado a las: {timestamp}")
    print("="*50 + "\n")

    # 5. L√≥gica de Negocio (Aqu√≠ es donde t√∫ a√±adir√≠as tu c√≥digo)
    # Ejemplo: if "hola" in text_content: ...
    
    logger.info(f"‚úÖ Mensaje de '{sender_phone}' procesado correctamente.")


# =============================================================================
# FIN DE LA FUNCI√ìN MEJORADA
# =============================================================================


def handle_user_status(data):
    """
    Maneja cambios de estado del usuario (typing indicators)
    """
    user_status = data.get('userStatus', {})
    sender_id = data.get('senderPhoneNumber', 'Unknown')
    is_typing = user_status.get('isTyping', False)
    
    logger.info(f"‚å®Ô∏è Estado de usuario:")
    logger.info(f"   Usuario: {sender_id}")
    logger.info(f"   Estado: {'escribiendo...' if is_typing else 'detuvo de escribir'}")


def handle_receipt(data):
    """
    Maneja confirmaciones de entrega/lectura
    """
    receipt = data.get('receipt', {})
    message_id = receipt.get('messageId', 'Unknown')
    receipt_type = receipt.get('receiptType', 'Unknown')
    timestamp = data.get('sendTime', '')
    
    logger.info(f"üìß Recibo:")
    logger.info(f"   Mensaje ID: {message_id}")
    logger.info(f"   Tipo: {receipt_type}")
    logger.info(f"   Timestamp: {timestamp}")


def handle_suggestion_response(data):
    """
    Maneja respuestas a sugerencias (botones, acciones sugeridas)
    """
    suggestion_response = data.get('suggestionResponse', {})
    sender_id = data.get('senderPhoneNumber', 'Unknown')
    postback_data = suggestion_response.get('postbackData', '')
    text = suggestion_response.get('text', '')
    
    logger.info(f"üîò Respuesta a sugerencia:")
    logger.info(f"   De: {sender_id}")
    logger.info(f"   Texto: {text}")
    logger.info(f"   Postback: {postback_data}")
    
    # TODO: Implementar l√≥gica seg√∫n el postback


@app.route('/health', methods=['GET'])
def health():
    """
    Endpoint de health check para monitoreo
    """
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat(),
        'secret_configured': bool(SECRET_KEY)
    }), 200


if __name__ == '__main__':
    if not SECRET_KEY:
        logger.warning("‚ö†Ô∏è" * 20)
        logger.warning("‚ö†Ô∏è MODO VALIDACI√ìN: SECRET_KEY no configurado")
        logger.warning("‚ö†Ô∏è El webhook aceptar√° todas las solicitudes")
        logger.warning("‚ö†Ô∏è Configura GOOGLE_WEBHOOK_SECRET despu√©s de la validaci√≥n")
        logger.warning("‚ö†Ô∏è" * 20)
    
    app.run(
        host='0.0.0.0',
        port=PORT,
        debug=os.getenv('FLASK_ENV') == 'development'
    )